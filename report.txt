LOCAL:
OS: Arch Linux x86_64
Processor: Intel i7-8550U
Cores: 8
RAM: 15.7GB

    | IVEC | LIST
----+------+-------
SYS | 0.01 |  0.02
PAR | 0.00 |  0.01
HW7 | 0.94 | 22.82

First, we did a pass through all functions which iterate through the entire list.
For some, there can be 'double duty', like coalescing while inserting. Just this
optimization alone cut our time by 40% or so. We started looking for more places
to optimize loops, but decided our time was better spent on handling
multi-threading properly.

The way we implemented multithreading was to add a per-thread free_list.
We did this with no shared free_list, to eliminate the difficulty and complexity
that comes with accessing shared data. This is terrible for space efficiency as
something might be freed in a different thread -- but removes any need for locks
and the slowdowns that come with them.

Simply applying this change caused a 10x performance increase.

Another quick optimization we did before our total rewrite was to increase the
"PAGE_SIZE" value to 65536 from 4096. This meant that we would be calling
malloc() less often.

This change bought us another ~2x performance increase


Next, we decided to try to write a bucket based allocator. We sought this
path because it would give constant time allocations and frees. Because we
weren't concerned with space complexity, we could get away with all of the
space inefficiencies that come with bucket allocators. We are extra space
inefficient because we don't actually share data between threads. This nets us
extra speed however, as we never have to handle lock contention.

The alternative would be a shared bucket system, but that would accomplish the
same thing and only give drawbacks, as there's no need to coalesce with the
bucket system.
